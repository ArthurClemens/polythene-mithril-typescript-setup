# `j2c` Plugin author notes

Out of the box, `j2c` is made of a frontend that walks a JS objets/arrays tree and calls the backend when necessary to emit atrules, rules and declarations.

The default backend fills a buffer with strings and `joins` them on completion.

`j2c` plugin can either tap into the frontend (by implementing custom at-rules), replace the backend, and insert middleware filters in between.

We'll process backwards and start by describing the backend, since understanding how it works is required to write filters and useful to write custom at-rules.

## `$sink` plugins: replace the backend


A `j2c` backend mus provide the following API:

```JS
{
    init() {},
    // called on `j2c.sheet()/j2c.inline()` invocations before 
    // the sheet is processed.
    done() {},
    // called when the tree traversal is finished, to finalize
    // the style sheet
    err(message) {},
    // called when an error is noticed, allows to display errors
    // in context.
    decl(property, value),
    // called to insert a declaration into the sheet
    rule(selector) {},
    // called to open a rule with a given selector
    _rule() {},
    // called to signal the end of a ruleset
    atrule(rule, kind, param, takesBlock)
    // called when an atrule is encountered.
    // `rule` is the rule name in full includin the '@' and the
    // prefix when there's one. e.g. `@-webkit-keyframes`
    // `kind` is the type of at-rule, without '@' nor prefix
    // e.g. `keyframes`
    // `param` is the optional parameter
    // `takesBlock` is a boolean that tells whether the rule 
    // takes a block or not. false for `@namespace`, `@charset`
    // and `@import`, true otherwise.
    _atrule(){}
    // called to signal the end of an atrule block
}
```

`j2c.inline()` uses the same API but restricted to `init()`, `done()`, `err(msg)` and `decl(property, value)`.

A plugin can be an object, a function or an array of zero or plugins (nested arrays are thus supported).

```JS
_j2c = j2c(
    {foo: 1}, 
    [
        {bar: 2},
        function(i) {
            i.baz = 3;
            return {qux: 4}
        }
    ]
)
```


Objects are used to non-destructively decorate the `j2c` instance. If a property is defined on both the instance and the plugin, the original field is preserved.

Functions are free to do whatever the please to the instance. If a function plugin returns an object, it is used as an object plugin.

In object plugins, properties starting with a `$` are not added to the instance. Instead, they may trigger custom behavior. Two special properties are currently supported: `$names` and `$filters`. 

- `$names` expects a class and animation names dictionary to (non-desrtuctively) extend the one of the instance.
- `$filter` expects a function that will wrap the buffer populating functions.

The `$filter` function recieves the buffer itself and the buffer setters, and is expected to return a new object with corresponding fields.

Filters are a bit hard to explain because they tap deeply into the innards of `j2c`. That was the best way I could add a reasonably powerful and efficient extension mechanism without blowing up the file size.

As `j2c` walks an object tree, it `.push()`es, on the fly,  parts of the sheets to a buffer (an array) that will be `.join('')`ed when done. 

The pushers object holds setters that wrap said pushing in different contexts: at-rules, selectors, declarations and closing braces.

```JS
{$filter: function (next) {
    return {
        x: function () {
            console.log(next.x(raw))
            console.log(next.x())
            return next.x()
        }, // the buffer
        a: function (rule, space, args, term) {
            console.log('at-rule', [rule, space, args, term])
            next.a(rule, space, args, term)
        },
        c: function()
    }
}}