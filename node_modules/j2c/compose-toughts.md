#Thinking `compose` thoroughly.

I've implemented something that works like @tivac's `composes` from `modular-css` as `@composes`, with proper credit, in the upcoming j2c v1.0 (it was initially added as `@extend`, dunno what I was thinking. SASS envy I guess).

(@tivac, I'm pinging you since AFAIK you invented the technique, and your feedback would be welcome)

Unlike the `composes`, `@composes` doesn't vet the class names, nor does it support the `from ...` syntax (you can only do so much with a single pass compiler in a stringly typed environment). 

`@compose` isn't required to be the first item in the block (the `@` is enough to signal that something special is occurring, and it would require additional code to keep track of the position in the object).

Because of how they are implemented, `compose` and `@compose` bring in the behavior of every selector involving the parents, along with conditional blocks and cascade rules. Therefore, I've limited the places where `@composes` is allowed, to avoid having possibly misleading code:

- it is prohibited in conditional at-rules like `@media`, because it would give the false impression that the composition only apply to that conditional block.

- it only works in the context of non-nested, single class selectors, or lists of single class selectors. That is, 

```JS
{'.foo, .bar': {'@composes': 'baz'}}`
```
will 'extend' both `foo` and `bar`, but 

```JS
{'.foo .bar': {'@composes': 'baz'}}`
```
and

```JS
{'.foo': {'& .bar': {'@composes': 'baz'}}}`
```
will be rejected. Extending both `foo` and `bar` would be a bad idea, and only extending `bar` would, once again, give the impression that the composition only applies when nested in `.foo` context, which isn't the case. I may relax 

A potential problem with both `composes` and `@composes` is the cascade. If a selector involving a parent class occurs in the source after one involving the child, the latter will take precedence if there are conflicting properties. I don't have a good solution for this in `j2c`, but you may have one for `modular-css`: repeat the child class name.

```CSS
.foo {
  composes: bar;
  color:red;
}
.bar {
  color:blue;
}
```

can be compiled to

```CSS
.foo.foo {
  color:red;
}
.bar {
  color:blue;
}
```

This raises the specificity of the first selector, and an element whose `class` is `'foo bar'` will be red. However, if you want this to work when the parent is itself using `compose`, you need to keep track of every `compose` in all dependent sheets, and multiply the child class such that `count(child) == max(parents.map(count))+1`.

Given these restrictions, It's likely I'll advise using `@compose` for inheriting properties of foreign frameworks (whose sheet is included independently, before any JS) and recommend using mixins when dealing with pure `j2c` code. I'm actually thinking of having `@compose` only take global rather than local class names as parameters (obviously, though the child/target must be local).